<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/base.css">
    <title>Document</title>
</head>
<body>
    <div class="container">
        <h2>setTimeout()</h2>
        <p> setTimeout() 在指定的时间后执行一段特定代码. 它需要如下参数:</p>
        <ul>
            <li>要运行的函数，或者函数引用。</li>
            <li>表示在执行代码之前等待的时间间隔(以毫秒为单位，所以1000等于1秒)的数字。如果指定值为0(或完全省略该值)，函数将尽快运行。</li>
            <pre>指定的时间（或延迟）不能保证在指定的确切时间之后执行，而是最短的延迟执行时间。
在主线程上的堆栈为空之前，传递给这些函数的回调将无法运行。
结果，像 setTimeout(fn, 0) 这样的代码将在堆栈为空时立即执行，而不是立即执行。
如果执行类似 setTimeout(fn, 0) 之类的代码，之后立即运行从 1 到 100亿 的循环之后，回调将在几秒后执行。 </pre>
            <li>更多的参数：在指定函数运行时，希望传递给函数的值。</li>
        </ul>
        <h3>传递参数给setTimeout() </h3>
        <pre>function sayHi(who) {
  alert('Hello ' + who + '!');
}
let myGreeting = setTimeout(sayHi, 2000, 'Mr. Universe');</pre>
        <h3>清除超时</h3>
        <p>如果创建了 timeout，您可以通过调用clearTimeout()，将setTimeout()调用的标识符作为参数传递给它，从而在超时运行之前取消。要取消上面的超时，你需要这样做：</p>
        <pre>clearTimeout(myGreeting);</pre>

        <hr>
        <h2>setInterval()</h2>
        <p>和setTimeout差不多，setInterval是多次执行，第二个参数是多久重复执行一次。</p>
        <h3>清除intervals</h3>
        <pre>const myInterval = setInterval(myFunction, 2000); clearInterval(myInterval);</pre>
        <hr>
        <iframe src="./clock.html" frameborder="0" width="100%" height="200PX"></iframe>
        <hr>
        <h2>关于setTimeout() / setInterval() 需要注意的几点</h2>
        <h3>递归timeouts</h3>
        <p>还有另一种方法可以使用setTimeout()：我们可以递归调用它来重复运行相同的代码，而不是使用setInterval()。</p>
        <pre>setTimeout(function run() {
    setTimeout(run, 1000);
}, 1000)</pre>
        <p><b>递归setTimeout()和setInterval()有何不同？</b></p>
        <ul>
            <li>递归 setTimeout() 保证执行之间的延迟相同，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li>
            <li>使用 setInterval() 的示例有些不同。 我们选择的间隔包括执行我们想要运行的代码所花费的时间。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li>
            <li>当递归使用 setTimeout() 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li>
        </ul>
        <p class="warning">当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 setTimeout() - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p>
        <h3>立即超时</h3>
        <p>使用0用作setTimeout()的回调函数会立刻执行，但是在主线程代码运行之后执行。</p>
        <pre>setTimeout(() => { alert('hello') },0)</pre>
        <p class="warning">如果您希望设置一个代码块以便在所有主线程完成运行后立即运行，这将很有用。将其放在异步事件循环中，这样它将随后直接运行。</p>
        <h3>使用 clearTimeout() or clearInterval()清除</h3>
        <p>clearTimeout() 和clearInterval() 都使用相同的条目列表进行清除。有趣的是，这意味着你可以使用任一一种方法来清除 setTimeout() 和 setInterval()。但为了保持一致性，你应该使用 clearTimeout() 来清除 setTimeout() 条目，使用 clearInterval() 来清除 setInterval() 条目。 这样有助于避免混乱。</p>
        <hr>
        <h2>requestAnimationFrame()</h2>
        <p class="warning">requestAnimationFrame() 是一个专门的循环函数，旨在浏览器中高效运行动画。它基本上是现代版本的setInterval() —— 它在浏览器重新加载显示内容之前执行指定的代码块，从而允许动画以适当的帧速率运行，不管其运行的环境如何。</p>
        <p class="warning">与setInterval()或setTimeout() 相比最近的浏览器支持requestAnimationFrame()— requestAnimationFrame().在Internet Explorer 10及更高版本中可用。因此，除非您的代码需要支持旧版本的IE，否则没有什么理由不使用requestAnimationFrame() 。</p>
    
    </div>

    <script>
        function sya(name) {
            console.log('你好 ' + name + ' !');
        }
        let say = setTimeout(sya, 3009, name);  // 将在主线程堆栈为空时执行

        clearTimeout(say);

        let container = document.querySelector('.container');
        let pTime = document.createElement('p');
        

        function timeInfo() {
            let dataTime = Date();
            let dataTimes = dataTime.split(' ');
            let dataYear = dataTimes[3];
            let m = dataTimes[0];
            let day = dataTimes[2];
            let hour = dataTimes[4].split(':')[0];
            let ms = dataTimes[4].split(':')[1];
            let s = dataTimes[4].split(':')[2];
            // console.dir(dataYear);
            // pTime.textContent = Date();
            pTime.textContent = dataYear + '  ' + m + '  ' + hour + ' : ' + ms + ' : ' + s;
            pTime.style.fontSize = '25px';
            container.appendChild(pTime);
        }

        let timeClick = setInterval(timeInfo,1000);
    </script>
</body>
</html>