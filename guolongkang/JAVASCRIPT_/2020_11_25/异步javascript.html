<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/base.css">
    <title>Document</title>
</head>
<body>
    <div class="container">
        <h2>异步代码</h2>
        <p>web workers相当有用，但是他们确实也有局限。主要的一个问题是他们不能访问 DOM — 不能让一个worker直接更新UI。我们不能在worker里面渲染1百万个蓝色圆圈，它基本上只能做算数的苦活。</p>
        <p>其次，虽然在worker里面运行的代码不会产生阻塞，但是基本上还是同步的。当一个函数依赖于几个在它之前运行的过程的结果，这就会成为问题。</p>
        <hr>
        <h3>异步callback</h3>
        <pre>function loadAsset(url, type, callback) {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = type;
  
    xhr.onload = function() {
      callback(xhr.response);
    };
  
    xhr.send();
  }
  
  function displayImage(blob) {
    let objectURL = URL.createObjectURL(blob);
  
    let image = document.createElement('img');
    image.src = objectURL;
    document.body.appendChild(image);
  }
  
  loadAsset('coffee.jpg', 'blob', displayImage);</pre>
        <p>不是所有的回调函数都是异步的 — 有一些是同步的。一个例子就是使用 Array.prototype.forEach() </p>
        <p>forEach() 需要的参数是一个回调函数，回调函数本身带有两个参数，数组元素和索引值。它无需等待任何事情，立即运行。</p>
        <hr>
        <h3>Promises</h3>
        <pre>fetch('products.json').then(function(response) {
   return response.json();
 }).then(function(json) {
   products = json;
   initialize();
 }).catch(function(err) {
   console.log('Fetch problem: ' + err.message);
 });</pre>
        <p>这里fetch() 只需要一个参数— 资源的网络 URL — 返回一个 promise. promise 是表示异步操作完成或失败的对象。可以说，它代表了一种中间状态。 本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。</p>        </p>
        <hr>
        <h4>事件队列</h4>
        <p>像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p>

    </div>
</body>
</html>